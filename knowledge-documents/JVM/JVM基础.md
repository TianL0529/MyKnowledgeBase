### JVM基础

**JVM是什么**

​		Java的流行很大一个因素都得益于它是一门款跨平台的语言，只需一次编译就可以在各个不同的平台运行。严格来说跨平台的特性并非Java语言的特性，其实提供这个特性的是JVM，只是我们经常说Java时默认已经把JVM算进来了。

​		这么说虽然没错但是确实不太准确，而且JVM从设计上看也并非只想运行Java语言，而是面向所有语言的运行平台，只要遵守JVM的约定(只要编译成.class文件)，那么任何语言都可以运行在JVM虚拟机上的，现在确实也有除了Java之外的很多语言都是运行在JVM上了，比如scala、kotlin、groovy等，所以综合来说JVM其实是一个独立的个体，它是一个可以运行任何语言的平台。

​	![img](D:\Desktop\知识整理\图片\v2-d04887ad9c193054dd11c53c73680ce7_720w.jpg)

**JDK、JRE、JVM的关系**

![img](D:\Desktop\知识整理\图片\v2-474bb4a444f55c754e26be7a54a3e5cd_720w.jpg)

* JVM：JVM是面向操作系统的，它负责把程序运行编译成的.Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行的内存的管理。
* JRE：JRE是是面向于程序的，JRE对JVM进行了一层包装，它除了提供JVM的功能之前，还提供了一套语言需要编译成Class后在JVM内运行所依赖环境（比如说 String.class、Object.class等这种运行时必须依赖的对象）。
* JDK：JDK是面向更上层的开发人员，JDK在JRE的基础上又进行了一层包装，它除了提供运行功能之外，还对开发人员提供了一套常用的开发工具和类库，来方便开发人员写代码（比如说方便部署的编译工具，方便开发的工具类等）。

#### **JVM的工作流程**

​		JVM只负责解释执行层面的工作，而具体的编译工作是没有纳入到JVM工作范围的，但是为了更清晰的理解JVM的功能又必须从编译开始了解。

**一个java文件从编码到执行需要经过下面几个阶段**：

![img](D:\Desktop\知识整理\图片\v2-56609c83569bd4f6f268a829b098a196_720w.jpg)

* 1.编译阶段：首先.java经过javac编译成.class文件；

  ​	类的编译阶段主要目的是把源码文件编译成JVM可以解析的class文件，这个阶段会经过词法分析、语法语义分析、生成字节码，这几个阶段后生成最后的class, 用16进制的方式打开class文件后内容大概如下图：

  ![image-20210719125742613](D:\Desktop\知识整理\图片\image-20210719125742613.png)

* 2.加载阶段：然后.class文件经过类的加载器加载到JVM内存，这个阶段会经过装载、连接、初始化三个过程；

  * 2.1 装载：装载阶段主要做的事情就是先把class的信息读到内存来。
    * 先通过类的全限定名读取到描述此类的二进制流。
    * 把字节流中描述静态结构的信息转化为方法区中的运行时数据结构。
    * 在Java堆中生成一个代表这个类的java.lang.Class对象，作为这个对象的访问入口。

  ```java
  public class TestJVM {
      public static int a;
      public static TestJVM testJVM;
  
      static {
          a=88;
          testJVM = new TestJVM();
      }
  }
  ```

  ​	上面的代码经过加载阶段后会在JVM内存保存着类的字节码，并且会生成一个TestJVM.Class对象，这个对象是作为TestJVM.class的统一访问入口，下图是按逻辑分区，并非数据实际保存物理位置。

  ![img](D:\Desktop\知识整理\图片\v2-c3e0237733011371dcb06f952561d2e2_720w.jpg)

  * 2.2 连接：连接阶段会对class的信息进行验证、为类变量分配内存空间并对其赋默认值。
    * 验证 :对class内容进行验证看字节信息是否符合JVM规范，包括元数据、字节码、符号引用的验证。
    * 准备: 为静态变量（final 和static定义的变量）分配内存空间，初始化静态变量值( int a=0, object=null的操作)。
    * 解析：把符号引用转换为直接引用，因为这里类的信息已经被加载到内存了，所以这里会把原来通过全限定名引用的对象替换成对象内存的实际地址。

  ![img](D:\Desktop\知识整理\图片\v2-8961df925ef3aef0d6df2687d5043b7d_720w.jpg)

  * 2.3 初始化：初始化阶段主要是执行初始化静态块内容，并且为静态变量进行真正的赋值操作，这里JVM会通过执行编译器自动生成的<clinit>() 方法（此方法是编译器通过搜集类的static{}静态快组成的代码）而完成具体工作。

  ![img](D:\Desktop\知识整理\图片\v2-d6dcd8696b8d5b5507512e0db8df02d2_720w.jpg)

* 解释阶段：class字节码经过字节码解释器解释成系统可识别的指令码；

  ​		解释阶段是在代码执行的时候来触发的，当我们尝试执行一个类的方法时，首先会通过这个类的对象作为入口，找到对应方法的字节码的信息，然后解析器会把字节码信息解释成系统能识别的指令码。

  ​		解释阶段会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器JIT，一般来说当我们运行某个代码的时候会默认使用字节码解释器进行指令解析，只有当某个方法称为热点方法后，即时编译器就会把热点方法的指令码保存起来，下次方法执行的时候就无需重复的进行解析，所以JIT是对解析过程中的一种优化手段。

* 执行阶段：系统再向硬件设备发送指令码执行操作。

------

#### JVM的内存分区

本部分主要探讨一下源码经过编译、加载后最终这些信息在JVM运行后是如何进行分类存储的。根据各种数据的特性JVM从逻辑上把内存划分成了以下几个区域：方法区（Method Area）、虚拟机栈（Java Virtual Machine Stacks）、本地方法栈（Native Method）、程序计数器（Program counter register）、堆（Heap） 5个区域，了解这几个分区对我们的编程和调优有着重要的意义，下面我们一起来逐个了解。

![img](D:\Desktop\知识整理\图片\20180224095734717)

* **方法区：**JVM方法区是用于保存已经被虚拟机加载的类元信息（包括类的版本、字段、方法、接口和父类等信息）、运行时常量信息(static、final定义的常量)、字符串常量信息(String a="dfc")。

  * 方法区、永久代、元数据区的关系：方法去是JVM定义的一种规范，是所有虚拟机需要遵守的约定，而“永久代（PermGen space）” 和 “元数据（MetaSpace）”都是实际某个虚拟机针对“方法区”的一种实现，“永久代”是JDK 1.7之前Hotspot虚拟机对方法区的实现（JDK 1.8被废除），而“元数据”则是1.8之后Hotspot虚拟机针对方法区的一种实现而已。

  * PermGen space和MetaSpace的区别：不管是PermGen space 还是 MetaSpace 他们都是Hotspot针对方法区的一种实现，两者最大的区别在于PermGen space 是在JVM虚拟机中分配内存的，而MetaSpace则分配在本地内存。

    ​		因为很多类是在运行期间加载的，这部分类加载的空间不可控，如果这部分内存是在JVM内存里分配的话，永久代分配太大那么JVM其他区域（比如说堆）的内存就会变小，反之如果设置太小，就容易出现方法区内存溢出(*java.lang.OutOfMemoryError: PermGen*)，因为本身存储的类信息属于不确定大小，类信息在我们运行的时候可以动态加载。所以JDK 1.8中选择把MetaSpace内存分配在本地内存，这样做的好处是MetaSpace空间的大小不会受限于虚拟机分配的内存大小，只会受限于机器内存，可分配的内存大了那么就不会那么容易出现内存溢。

  * 字符串常量、静态变量数据存放区域：Java 6中 所有常量池数据是存放在永久代中，但到Java 7后 Hotspot 把永久代中的字符串常量、静态变量数据迁移到了堆中，后面的Java 8并没有对这部分内容进行迁移，在Java 8 中字符串常量、静态变量数据还是放到堆中，所以常量池只是在JVM规范定义上属于方法区，但Hotspot在实现的时候部分常量池的内容实际上是保存在堆中了。

* **虚拟机栈：**栈这部分区域主要是用于线程运行方法的区域，此区域属于线程私有的空间，每一个线程创建后都会申请一个自己单独的栈空间，每一个方法的调用都会对应着一个栈帧。

  ​		栈帧里存储着方法的局部变量表（保存着变量的数据）、操作数栈(进行运算时存放数据的空间)、动态连接（指向常量池的引用）和方法返回地址（当前方法返回后的数据存放的地方）信息。

  ​		每调用一个方法都会生成一个新的栈帧，调用方法的过程就是一个压栈和出栈的过程，遵循先进后出的原则，比如下面代码,用 main() 调用 test1() 再条用test2()的执行过程类似于下图。

```java
public class TestStack {

    public static void main(String[] args) {
        System.out.println("执行main方法");
        test1();

    }

    public static void  test1(){
        System.out.println("test-1");
                test2();
    }

    public static void  test2(){
        System.out.println("test-2");
    }
    
}
```

**压榨出栈过程**

![img](D:\Desktop\知识整理\图片\v2-f69b21bc8acb1841e703ff4c67e195cc_720w.jpg)

* **本地方法栈：**由于java需要与一些底层系统如操作系统或某些硬件交换信息时的情况，这个时候就需要通过调用native本地方法来实现，本地方法栈和虚拟机栈功差不多，区别在于本地方法栈是虚拟机调用native方法时使用的。

* **程序计数器：**程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，程序计数器记录着某个线程当前执行指令的位置，此区域属于线程隔离区。

  ​		因为CPU是根据时间片的方式分配资源的，它在某一个线程上进行调度的时间是一个或者多个时间片，所以当CPU从A线程切换到B线程执行时，就需要记录A线程当前指令所在的位置，方便CPU再次切回A线程时可以从上次的位置开始继续执行指令， 而程序计数器就是用来记录线程指令历史位置的区域。

![img](D:\Desktop\知识整理\图片\v2-286825748bd11ead9e724164e4138c7d_720w.jpg)

* **堆：**堆内存主要是用来存放创建的对象数据，此区域属于线程共享区对于开发人员来说这块区域关注的比较多，因为很多优化都是针对这块区域来进行的，为了能更清楚的描述堆里的数据和分区信息，所以会结合垃圾回收的一些机制来描述这块内存区域。

  * **新生代和老年代划分机制：**堆内存主要是用来存放我们运行过程中创建的对象数据，根据对象所生存时间长短的特性在逻辑上分为 新生代和老年代。

    对于JVM而言，大部分对象都是属于一个朝生夕死的状态，这部分对象随着方法的调用而创建，方法的结束而消亡，只有少部分的对象会长久的留在JVM 内存中，所以根据这样的特性JVM 把内存分为了新生代 和老年代两个区，一般情况新创建的对象会放到新生代中，只有经过一定次数的GC后还没有被回收的对象，我们认为这部分对象在未来也会长时间存在，所以会把这部分的对象转移到老年代的区域中去。

    <img src="D:\Desktop\知识整理\图片\v2-d1934ddada92ee1af46b94dc0d9127a9_720w.jpg" alt="img" style="zoom: 67%;" />

  * Eden区和Survior划分机制

    我们尝试想象一下，如果新生代不进行任何分区，我们垃圾回收的过程是怎样的。

    * 首先我们会把为垃圾的对象进行标记。
    * 然后把标记为垃圾的对象进行清除。

    ​		**过程类似下图：**

    ![img](D:\Desktop\知识整理\图片\v2-7c8d60af0215cfc6d5ef92613ed636f1_720w.jpg)

    ​		通过上面的图我们可以看出来，GC把垃圾对象回收后如果不对存活下来的对象进行整理，那么就会出现很多不连续的内存空间，这也就是我们常说的空间碎片，因为没有连续的空间分配，这样就可能造成我们一个大对象过来我们没有对应的连续空间分配，但是内存里其实是有能够容纳对象的总空间的。

    ​		所以为了减少这种空间碎片，我们就使用了另一种方式，把新生代分为了Eden 区和Survior 区，在进行垃圾回收时，先把存活的对象复制到 Survior 区，然后再对Eden区统一进行清理，这样的话Eden区每次GC过后都是留下的一片连续的空间：

    ![img](D:\Desktop\知识整理\图片\v2-e65c384d5bb881517ffa4736c83cff26_720w.jpg)

    

    

    

  * S1区和S2区划分机制

    ​		上面我们把新生代划分为Eden区和Survior区后，空间碎片问题好像改善了很多，因为这样解决了Eden区的空间碎片问题，但是这样的话我们忽略了一个问题，空间碎片问题Survior 区也会存在，因为进行GC时，我们Survior 区也会有垃圾对象，所以每次GC也会对Survior 区进行标记清除，那么这样的话Survior 区也同样会出现不连续的空间。

![img](D:\Desktop\知识整理\图片\v2-f064bcd9230b9b9105161fb2b237d9a3_720w.jpg)

​		为了避免Survior区的空间碎片，所以我们把Survior 分成了S1区和S2区，在同一时间S1和S2区只会有一个存放对象，每次进行垃圾回收的时候，我们都会把不能进行回收的对象放到S1或S2其中的某一个区，垃圾回收的流程类似下面几个步骤。

* 1、 第一次GC我们会把Eden区的不可回收对象拷贝到S1区，然后把Eden区的所有对象进行清理。

* 2、第二次GC我们会把Eden区和S1区不可回收的对象拷贝到S2区，然后把Eden区和S1区的所有对象进行清理。

* 3、第三次GC我们会把Eden区和S2区不可回收的对象拷贝到S1区，然后把Eden区和S2区的所有对象进行清理。

  ..........

![img](D:\Desktop\知识整理\图片\v2-f9cca1f7b68a36a984d16299e4633a1d_720w.jpg)

最后经过了一些特定区域职责划分后，堆内存划分为 老年代、新生代，新生代又划分为Eden区、s1区、s2区域。

<img src="D:\Desktop\知识整理\图片\v2-d1878a336726adbd7a33f877909fdf80_720w.jpg" alt="img" style="zoom:67%;" />

------

### 一个对象的创建过程

这里通过一个类的代码分别追踪类的静态变量、成员变量、在经过静态快、对象代码块的变更后，最终创建完的对象在内存中是如何标示和保存的，演示流程和代码如下：

![img](https://pic1.zhimg.com/80/v2-3bad66929576d72eaf0187d45cef3740_720w.png)

```java
public class Person {

    //静态变量
    public  static  int staicVariabl=1;
    //成员变量
    public   int  objVariabl;

    //静态初始代码块
    static {
        staicVariabl=2;
    }

    //对象初始化代码块
    {
        objVariabl=88;
    }

    //构造方法
    public Person() {
        objVariabl=99;
    }

    public static void main(String[] args) {
        Person person=new Person();
    }

}
```

**1.编译**：经过编译后Person.java 会生成一个Person.class文件。

![img](D:\Desktop\知识整理\图片\v2-9302116ac83a156973747a62cdfc20db_720w.jpg)

**2.装载：**Person.class经过加载后，会把类的相关信息加载到 JVM 内存中，解析出类的描述信息会保存到MetaSpace,同时这里会生成一个代表这个类的 java.lang.Class 对象，作为这个类的各种数据的访问入口。

![img](D:\Desktop\知识整理\图片\v2-ad579dcd3ccda458007a62a6b6957755_720w.jpg)

**3.连接：**连接阶段会对静态变量的值进行默认赋值，此时Person类的staicVariabl 赋值为0；

![img](D:\Desktop\知识整理\图片\v2-34b32035bfb283ae41d0a758c95f9c7d_720w.jpg)

**4.初始化：**

* 1、首先会对Person类的静态变量staicVariabl 进行真正的赋值的操作（此时staicVariabl =1）。
* 2、然后收集类的静态代码块内容，生成一个类的<clinit>() 方法并执行（此时staicVariabl =2）。

![img](D:\Desktop\知识整理\图片\v2-68a47c8ec6bab6c927887e0ae71ebb8b_720w.jpg)

**5.创建对象：**当我们new一个对象的时候JVM首先会去找到对应的类元信息，如果找不到意味着类信息还没有被加载，所以在对象创建的时候也可能会触发类的加载操作。当类元信息被加载之后，我们就可以通过类元信息来确定对象信息和需要申请的内存大小。

​		对象创建的流程：当我们执行上面代码中main方法中的的 Person person=new Person() 时，我们的对象就开始创建了，执行流程大致分为三步：

* **1、构建对象：**首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧（栈帧就是利用EBP`栈帧指针`寄存器访问局部变量、参数、函数返回地址等的手段）。然后执行new Person() ，这里会根据 Person 类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息赋默认值。

![img](D:\Desktop\知识整理\图片\v2-d044615dda872c4c5cdac78332707cd7_720w.jpg)

* **2、初始化对象：**然后执行对象内部生成的 init 方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后 objVariabl=88，构造方法执行完后 objVariabl=99)。

![img](D:\Desktop\知识整理\图片\v2-793d97f0b1465aa7d72414f4e989563a_720w.jpg)

* **3、引用对象：**对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。

![img](D:\Desktop\知识整理\图片\v2-1bb56c62cedb42d38600f2a0125afeb6_720w.jpg)

**6.对象在内存的布局：**对象创建完成后在内存中保存的信息包括对象头（Header）、实例数据（Instance Data）及对齐填充（Padding） 三类信息。

* **对象头：**对象头里主要包括几类信息，分别是锁状态标志、持有锁的线程ID、GC分代年龄、对象HashCode，类元信息地址、数组长度，这里并没有对对象头里的每个信息都列出而是进行大致的分类，下面是对其中几类信息进行说明。
  * **锁状态标志：**对象的加锁状态分为无锁、偏向锁、轻量级锁、重量级锁几种标记。
  * **持有锁的线程**： 持有当前对象锁定的线程ID。
  * **GC分代年龄：** 对象每经过一次GC还存活下来了，GC年龄就加1。
  * **类元信息地址：** 可通过对象找到类元信息，用于定位对象类型。
  * **数组长度：** 当对象是数组类型的时候会记录数组的长度。
* **实例数据：**对象实例数据才是对象自身真正的数据，主要包括自身的成员变量信息，同时还包括实现的接口、父类的成员变量信息。
* **对齐填充：**根据JVM规范对象申请的内存地址必须是8的倍数，换句话说对象在申请内存大小时候8字节的倍数，如果对象自身的信息大小没有达到申请的内存大小，那么这部分是对剩余部分进行填充。

**Person对象最终创建完成后内存中数据情况大概如下图：**

![img](D:\Desktop\知识整理\图片\v2-ed45fff063164e49b9ad0a9a91dabd90_720w-1626689206650.jpg)



























